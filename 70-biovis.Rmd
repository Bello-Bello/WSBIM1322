# Visualising biomolecular data {#sec:biovis}

The goal of this chapter is to learn some additional visualisation
that are widely used in biomedical data analysis, namely

- **Heatmaps**, including an application of the hierarchical
  clustering that was seen in chapter \@ref(sec:ul).
- Visualisation of intersections, in particular **Venn** and **UpSet**
  plots.
- The `r BiocStyle::Biocpkg("Gviz")` to visualise genomic data.

## Heatmaps


## Effect of distance and clustering algorithm

It is important to highlight that the type of distance and the type of
clustering algorithms will affect the result. Let's observe how using
the euclidean or Pearson correlation distances between expression
profiles can fundamentally change the results.

```{r disttoyexample}
## toy example: 3 genes, 5 samples from Olga Vitek
gene1 <- c(1, 6, 2, 4, 7)
gene2 <- gene1 + 4
gene3 <- gene2/3 + c(0, 2, 0, 4, 0)
e <- rbind(gene1, gene2, gene3)
dimnames(e) <- list(paste0("gene", 1:3),
					paste0("sample", 1:5))
e
matplot(t(e), type = "b", xlab = "Samples", ylab = "Expression")
```

```{r hclbiodist}
library("bioDist")
par(mfrow = c(1, 2))
plot(hclust(euc(e)), main = "Euclidean distane")
plot(hclust(cor.dist(e)), main = "Pearson correlational distance")
```


Many of the machine learning methods that are regularly used are
sensitive to difference scales. This applies to unsupervised methods
as well as supervised methods. Below, we show how centering and
scaling the data (row-wise, hence the transposition) affects the
euclidean distance but not the Pearson correlation distance.

```{r hclscale, fig.with = 10, fig.height = 7}
e2 <- t(scale(t(e)))
## or manually
## e2 <- (e - rowMeans(e)) / genefilter::rowSds(e)
matplot(t(e2), type = "b", xlab = "Samples", ylab = "Expression")
par(mfrow = c(2, 2))
plot(hclust(euc(e)), main = "Euclidean distance")
plot(hclust(euc(e2)), main = "Euclidean distance (scaled/centred)")
plot(hclust(cor.dist(e)), main = "Pearson correlational distance")
plot(hclust(cor.dist(e2)), main = "Pearson correlational distance (scaled/centred)")
```
## Heatmaps

```{r heatmap_mulvey, cache = TRUE}
data(mulvey2015norm)
heatmap(MSnbase::exprs(mulvey2015norm))
```

A heatmap is composed of two hierarchical clusters (one along the
rows, one along the columns, leading to their re-ordering based on
their similarity) and a intensity matrix. Each of these components is
subject to parameters and options.

As we have seen above, the distance used for clustering can have a
substantial effect on the results, which is conformed below.

```{r heatmapcor, cache = TRUE}
heatmap(MSnbase::exprs(mulvey2015norm), distfun = cor.dist)
```

Another important argument, `scale` controls whether rows, columns or
none are scaled. Let's re-use the toy data from the hierarchical
clustering section below.

```{r heatmapscale}
heatmap(e, scale = "none", main = "No scaling")
heatmap(e, scale = "row", main = "Scaling along rows")
heatmap(e, scale = "column", main = "Scaling along columns")
```

Based on the caveats above, it is essential to present and interpret
heatmaps with great care. It is of course possible to use any type of
data, not only expression data, to build a heatmap.

There exists several packages that allow to produce heatmaps with
various levels of sophistication, such as `heatmap.2` from the `r
CRANpkg("gplots")` package, the `r Biocpkg("Heatplus")` package, or
the `r Biocpkg("ComplexHeatmap")` packages (full documentation
[here](https://jokergoo.github.io/ComplexHeatmap-reference/book/index.html)),
demonstrated below.

```{r complexheatmap}
library("ComplexHeatmap")
x <- MSnbase::exprs(mulvey2015norm)
hcl <- hclust(dist(x))
cl <- cutree(hcl, k = 12)
ha1 <- HeatmapAnnotation(time = factor(mulvey2015norm$time))
ha2 <- HeatmapAnnotation(boxplot = anno_boxplot(x))
ha3 <- rowAnnotation(cluster = factor(cl))
Heatmap(x,
		top_annotation = ha1,
		bottom_annotation = ha2,
		column_names_gp = gpar(fontsize = 8),
		row_names_gp = gpar(fontsize = 3)) + ha3
```

Finally, the `r Githubpkg("talgalili/heatmaply")`,
`r Githubpkg("rstudio/d3heatmap")` and [`iheatmapr`](https://ropensci.github.io/iheatmapr/index.html)
packages can be used to generate interactive heatmaps.

```{r heatmaply, eval = FALSE}
library("heatmaply")
heatmaply(MSnbase::exprs(hlm)[1:100, ])
```

```{r heatmaply2, eval = FALSE}
heatmaply(MSnbase::exprs(hlm)[1:100, ],
		  RowSideColors = as.factor(fData(hlm)$markers[1:100]))
```

```{r d3hm, eval = FALSE}
library("d3heatmap")
d3heatmap(MSnbase::exprs(hlm))
```

Reference:

> Key M. *A tutorial in displaying mass spectrometry-based proteomic
> data using heat maps*. BMC Bioinformatics. 2012;13 Suppl
> 16:S10. doi:
> [10.1186/1471-2105-13-S16-S10](https://doi.org/10.1186/1471-2105-13-S16-S10). Epub
> 2012 Nov 5. Review. PMID: 23176119; PMCID: PMC3489527.




## Visualising intersections between sets

Venn and Euler diagrams are popular representation when comparing sets
and their intersection. Two useful R packages to generate such plots
are `r CRANpkg("venneuler")` and `r Githubpkg("js229/Vennerable")`.

We will use the `crc` feature names to generate a test data:

```{r venn}
set.seed(123)
library("pRolocdata")
data(mulvey2015)
x <- replicate(3, sample(featureNames(mulvey2015), 555), simplify = FALSE)
names(x) <- LETTERS[1:3]
library("Vennerable")
(v <- Venn(x))
## access the identifiers
v@IntersectionSets[["110"]]
plot(v)
```

The `r CRANpkg("UpSetR")` visualises intersections of sets as a matrix
in which the rows represent the sets and the columns represent their
intersection sizes. For each set that is part of a given intersection,
a black filled circle is placed in the corresponding matrix cell. If a
set is not part of the intersection, a light gray circle is shown. A
vertical black line connects the topmost black circle with the
bottom most black circle in each column to emphasise the column-based
relationships. The size of the intersections is shown as a bar chart
placed on top of the matrix so that each column lines up with exactly
one bar. A second bar chart showing the size of the each set is shown
to the left of the matrix.

We will first make use of the `fromList` function to convert our list
to a `UpSetR` compatible input and then generate the figure:

```{r upset1}
library("UpSetR")
x2 <- fromList(x)
upset(x2)
```

The following
[tweet](https://twitter.com/ngehlenborg/status/986354574989709312) by
the author of the package illustrates how Venn and upset diagrams
relate to each other.


```{r upset2}
upset(x2, order.by = "freq")
upset(x2, order.by = "degree")
upset(x2, order.by = c("freq", "degree"))
upset(x2, order.by = c("degree", "freq"))

upset(x2, sets = c("A", "B"))
upset(x2, sets = c("B", "C", "A"), keep.order = TRUE)

upset(x2, group.by = "sets")

## Add set D with a single intersection
x3 <- x2
x3$D <- 0
x3[1, "D"] <- 1
head(x3)

upset(x3)
upset(x3, empty.intersections = "on")
```

Visualising intersections with `UpSetR` shines with more that 4 sets,
as Venn diagrams become practically useless.


There is also am UpSetR online app: https://gehlenborglab.shinyapps.io/upsetr/

`r msmbstyle::question_begin()`

Generate a bigger dataset containing 10 sets. Try to generate Venn and
upset diagrams as shown above.

When the number of sets become larger, the options above, as well as
`nsets`, the number of sets (default is 5) and `nintersects`, the
number of intersectios (default is 40) become useful.

`r msmbstyle::question_end()`

`r msmbstyle::solution_begin()`

```{r upsetchallenge}
set.seed(123)
x <- replicate(10, sample(featureNames(mulvey2015), 555), simplify = FALSE)
names(x) <- LETTERS[1:10]
x <- fromList(x)
upset(x)
```

`r msmbstyle::solution_end()`


## Data along genomic corrdinates
