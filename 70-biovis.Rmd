# Visualising biomolecular data {#sec:biovis}

The goal of this chapter is to learn some additional visualisation
that are widely used in biomedical data analysis, namely

- **Heatmaps**, including an application of the hierarchical
  clustering that was seen in chapter \@ref(sec:ul).
- Visualisation of intersections, in particular **Venn** and **UpSet**
  plots.
- The `r BiocStyle::Biocpkg("Gviz")` to visualise genomic data.


## Heatmaps


```{r heatmapmulvey, cache = TRUE, fig.cap = "Heatmap of the (normalised) Mulvey et al. 2015 proteomic data."}
data(mulvey2015norm)
heatmap(MSnbase::exprs(mulvey2015norm))
```

A heatmap is composed of two hierarchical clusters (one along the
rows, one along the columns, leading to their re-ordering based on
their similarity) and a intensity matrix. Each of these components is
subject to parameters and options.

As we have seen above, the distance used for clustering can have a
substantial effect on the results, which is conformed below.


```{r heatmapcor, cache = TRUE, fig.cap = "Heatmap of the (normalised) Mulvey et al. 2015 proteomic data using correlation distances."}
heatmap(MSnbase::exprs(mulvey2015norm), distfun = cor.dist)
```


Another important argument, `scale` controls whether rows, columns or
none are scaled. Let's re-use the toy data from the hierarchical
clustering section below.



```{r heatmapscale1, fig.cap = "Effect of scaling on the heatmap output: no scaling."}
library("rWSBIM1322")
data(g3)
heatmap(g3, scale = "none", main = "No scaling")
```

```{r heatmapscale2, fig.cap = "Effect of scaling on the heatmap output: scaling along the rows."}
library("rWSBIM1322")
data(g3)
heatmap(g3, scale = "row", main = "Scaling along rows")
```

```{r heatmapscale3, fig.cap = "Effect of scaling on the heatmap output: scaling along the columns."}
library("rWSBIM1322")
data(g3)
heatmap(g3, scale = "column", main = "Scaling along columns")
```

Based on the caveats above, it is essential to present and interpret
heatmaps with great care. 


There exists several packages that allow to produce heatmaps with
various levels of sophistication, such as `heatmap.2` from the `r
CRANpkg("gplots")` package, the `r Biocpkg("Heatplus")` package, or
the `r Biocpkg("ComplexHeatmap")` packages (full documentation
[here](https://jokergoo.github.io/ComplexHeatmap-reference/book/index.html)),
demonstrated below.


```{r complexheatmap, fig.fullwidth = TRUE, message = FALSE, fig.cap = "An annotated heatmap produced with the `ComplexHeatmap` Bioconductor package."}
library("ComplexHeatmap")
x <- MSnbase::exprs(mulvey2015norm)
hcl <- hclust(dist(x))
cl <- cutree(hcl, k = 12)
ha1 <- HeatmapAnnotation(time = mulvey2015norm$time)
ha2 <- HeatmapAnnotation(boxplot = anno_boxplot(x))
ha3 <- rowAnnotation(cluster = factor(cl))
Heatmap(x,
        top_annotation = ha1,
        bottom_annotation = ha2,
        column_names_gp = gpar(fontsize = 8),
        row_names_gp = gpar(fontsize = 3)) +
    ha3
```


Finally, the `r Githubpkg("talgalili/heatmaply")`,
`r Githubpkg("rstudio/d3heatmap")` and [`iheatmapr`](https://ropensci.github.io/iheatmapr/index.html)
packages can be used to generate interactive heatmaps.


```{r heatmaply, eval = FALSE}
library("heatmaply")
heatmaply(MSnbase::exprs(hlm)[1:100, ])
```

```{r heatmaply2, eval = FALSE}
heatmaply(MSnbase::exprs(hlm)[1:100, ],
		  RowSideColors = as.factor(fData(hlm)$markers[1:100]))
```

```{r d3hm, eval = FALSE}
library("d3heatmap")
d3heatmap(MSnbase::exprs(hlm))
```

See also *A tutorial in displaying mass spectrometry-based proteomic
data using heat maps* [@Key:2012], that applies to any type of omics
data (not only proteomics) for a useful reference.


## Visualising intersections between sets

Venn and Euler diagrams are popular representation when comparing sets
and their intersection. Two useful R packages to generate such plots
are `r CRANpkg("venneuler")` and `r Githubpkg("js229/Vennerable")`.

We will use the `crc` feature names to generate a test data:

```{r venn}
set.seed(123)
library("pRolocdata")
data(mulvey2015)
x <- replicate(3, sample(featureNames(mulvey2015), 555), simplify = FALSE)
names(x) <- LETTERS[1:3]
library("Vennerable")
(v <- Venn(x))
## access the identifiers
v@IntersectionSets[["110"]]
plot(v)
```

The `r CRANpkg("UpSetR")` visualises intersections of sets as a matrix
in which the rows represent the sets and the columns represent their
intersection sizes. For each set that is part of a given intersection,
a black filled circle is placed in the corresponding matrix cell. If a
set is not part of the intersection, a light gray circle is shown. A
vertical black line connects the topmost black circle with the
bottom most black circle in each column to emphasise the column-based
relationships. The size of the intersections is shown as a bar chart
placed on top of the matrix so that each column lines up with exactly
one bar. A second bar chart showing the size of the each set is shown
to the left of the matrix.

We will first make use of the `fromList` function to convert our list
to a `UpSetR` compatible input and then generate the figure:

```{r upset1}
library("UpSetR")
x2 <- fromList(x)
upset(x2)
```

The following
[tweet](https://twitter.com/ngehlenborg/status/986354574989709312) by
the author of the package illustrates how Venn and upset diagrams
relate to each other.


```{r upset2}
upset(x2, order.by = "freq")
upset(x2, order.by = "degree")
upset(x2, order.by = c("freq", "degree"))
upset(x2, order.by = c("degree", "freq"))

upset(x2, sets = c("A", "B"))
upset(x2, sets = c("B", "C", "A"), keep.order = TRUE)

upset(x2, group.by = "sets")

## Add set D with a single intersection
x3 <- x2
x3$D <- 0
x3[1, "D"] <- 1
head(x3)

upset(x3)
upset(x3, empty.intersections = "on")
```

Visualising intersections with `UpSetR` shines with more that 4 sets,
as Venn diagrams become practically useless.


There is also am UpSetR online app: https://gehlenborglab.shinyapps.io/upsetr/

`r msmbstyle::question_begin()`

Generate a bigger dataset containing 10 sets. Try to generate Venn and
upset diagrams as shown above.

When the number of sets become larger, the options above, as well as
`nsets`, the number of sets (default is 5) and `nintersects`, the
number of intersectios (default is 40) become useful.

`r msmbstyle::question_end()`

`r msmbstyle::solution_begin()`

```{r upsetchallenge}
set.seed(123)
x <- replicate(10, sample(featureNames(mulvey2015), 555), simplify = FALSE)
names(x) <- LETTERS[1:10]
x <- fromList(x)
upset(x)
```

`r msmbstyle::solution_end()`


## Data along genomic coordinates
