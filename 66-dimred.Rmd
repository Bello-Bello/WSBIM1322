# Dimensionality reduction {#sec:dimred}

## Introduction

In this chapter, we are going to learn about dimensionality reduction,
also called ordination. The goal of dimensionality reduction is to
transform a high-dimensinal data into data of lesser dimensions while
minimise the loss of information.

Dimensionality reduction is used as a data transformation technique
for input to other machine learning methods such as classifications,
or as a very efficient visualisation technique, which is the use case
we will focus on here. We are going to focus on a widerly used method
called Principal Component Analysis (PCA).


```{r pcaexdata, echo = FALSE}
set.seed(122)
n <- 20
gene_x <- sort(rnorm(n, 6, 1))
gene_y <- gene_x + rnorm(10)
xy0 <- data.frame(gene_x, gene_y)
xy <- data.frame(scale(xy0))
```

We are going to use the following dataset to illustrate some important
concepts that are scale and central to PCA. The small dataset show
below represents the measurement of genes *x* and *y* in 20
samples. We will be using the scaled and centred version of this data.

```{r xyplot, echo = FALSE, fig.cap = "Raw (left) and scale/centred (right) expression data for genes *x* and *y* in 20 samples", fig.height = 5, fig.width = 11}
library("ggplot2")
library("patchwork")

## original data
p0 <- ggplot(xy0, aes(x = gene_x, y = gene_y)) +
    geom_point(shape = 21, size = 3)

## scaled data
p <- ggplot(xy, aes(x = gene_x, y = gene_y)) +
    geom_point(shape = 21, size = 3)

p0 + p
```

## Lower-dimensional projections

The goal of dimensionality reduction is to reduce the number of
dimensions in a way that the new data remains useful. One way to
reduce a 2-dimensional data is by projecting the data onto a
lines. Below, we project our data on the x and y axes. These are
called **linear projections**.

```{r linproj, echo = FALSE, fig.cap = "Projection of the data on the x (left) and y (right) axes.", fig.heigth = 5, fig.width = 11}

## projection on y = 0
py <- p + 
    geom_point(aes(y = 0), colour = "red") +
    geom_segment(aes(xend = gene_x, yend = 0), linetype = "dashed")

## projection on x = 0
px <- p + 
    geom_point(aes(x = 0), colour = "red") +
    geom_segment(aes(yend = gene_y, xend = 0), linetype = "dashed")

## projections on x = 0 and y = 0
py + px
```

In general, and in particular in the projections above, we loose
information when reducing the number of dimensions (above, from 2
(plane) to 1 (line)). In the first example above (left), we loose all
the measurements of gene *y*. In the second example (right), we loose
all the measurements of gene *x*. 

The goal of dimensionality reduction is to limit this loss.

We know already about **linear regression**. Below, we use the `lm`
function to regress *y* onto *x* (left) and *x* onto *y*
(right). These regression lines give us an approximate linear
relationship between the expression of genes *x* and *y*. The
relationship differs depending on which gene we choose to be the
predictor adn the response.


```{r linreg, echo = FALSE, fig.cap = "Regression of y onto x (left) minimisises the sums of squares of vertical residuals (red). Regression of x onto y (right) minimisises the sums of squares of horizontal residuals (orange).", fig.width = 5, fig.width = 11}
reg1 <- lm(gene_y ~ gene_x, data = xy)
a1 <- reg1$coefficients[1] # intercept
b1 <- reg1$coefficients[2] # slope
pline1 <- p +
    geom_abline(intercept = a1, slope = b1, col = "blue", lwd = 1.5) +
    geom_segment(aes(xend = gene_x, yend = reg1$fitted),
                 colour = "red",
                 arrow = arrow(length = unit(0.15, "cm")))

reg2 <- lm(gene_x ~ gene_y, data = xy)
a2 <- reg2$coefficients[1] # intercept
b2 <- reg2$coefficients[2] # slope
pline2 <- p +
    geom_abline(intercept = -a2/b2, slope = 1/b2,
                col = "blue", lwd = 1.5) +
    geom_segment(aes(xend = reg2$fitted, yend = gene_y),
                 colour = "orange",
                 arrow = arrow(length = unit(0.15, "cm")))

pline1 + pline2
```

We now want a line that minimises distances in both directions, as
shown below. This line, called **principal compoment**, is also the
ones that maximises the variance of the projections along itself.

```{r pxaex, echo = FALSE, fig.cap = "The first prinicpal component minimises the sum of squares of the orthogonal projections.", fig.height = 5.8, fig.width = 11}
svda <- svd(xy)
pc <- as.matrix(xy) %*% svda$v[, 1] %*% t(svda$v[, 1])
bp <- svda$v[2, 1] / svda$v[1, 1]
ap <- mean(pc[, 2]) - bp * mean(pc[, 1])
pline3 <- p +
    geom_segment(xend = pc[, 1], yend = pc[, 2]) +
    geom_abline(intercept = ap, slope = bp,
                col = "purple", lwd = 1.5)

ppdf <- tibble(PC1n = -svda$u[, 1] * svda$d[1],
               PC2n = svda$u[, 2] * svda$d[2])

pca <- ggplot(ppdf, aes(x = PC1n, y = PC2n)) +
    geom_point(shape = 21, size = 3) +
    xlab("PC1 ") + ylab("PC2") +
    geom_point(aes(x = PC1n, y = 0), color = "red") +
    geom_segment(aes(xend = PC1n, yend = 0)) +
    geom_hline(yintercept = 0, color = "purple",
               lwd=1.5)

pline3 + pca
```

The second principal component is then chosen to be orthogonal to the
first one. In our case above, there is only one possibility. 


```{r pxaex2, echo = FALSE, fig.cap = "The second prinicpal component is orthogonal to the second one.", fig.height = 5.8, fig.width = 11}
pca2 <- ggplot(ppdf, aes(x = PC1n, y = PC2n)) +
    geom_point(shape = 21, size = 3) +
    xlab("PC1 ") + ylab("PC2") +
    geom_point(aes(x = PC1n, y = 0), color = "red") +
    geom_segment(aes(xend = PC1n, yend = 0), linetype = "dotted") +    
    geom_segment(aes(x = PC1n, xend = 0, y = PC2n, yend = PC2n)) +
    geom_hline(yintercept = 0, color = "purple",
               lwd=1) + 
    geom_vline(xintercept = 0, color = "purple",
               lwd=1.5)

pca + pca2
```

```{r prcomp, echo = FALSE}
.pca <- prcomp(xy)
var <- .pca$sdev^2
pve <- var/sum(var)
```
In the example above the variance, the variance along the PCs are 
`r round(var[1], 2)` and `r round(var[2], 2)`. The first one explains 
`r round(pve[1] * 100, 1)`% or that variance, and the second one merely 
`r round(pve[2] * 100, 1)`%. This is also reflected in the different 
scales along the x and y axis. 

To account for these differences in variation along the different PCs,
it is better to represent a PCA plot as a rectangle, using an aspect
ratio that is illustrative of the respective variances.

```{r pxaex3, echo = FALSE, fig.cap = "Final principal component analysis of the data.", fig.height = 2, fig.width = 10}
pca_final <- pca2 <- ggplot(ppdf, aes(x = PC1n, y = PC2n)) +
    geom_point(shape = 21, size = 3) +
    xlab("PC1 ") + ylab("PC2") 
    ## geom_hline(yintercept = 0) + 
    ## geom_vline(xintercept = 0)
pca_final
```


## The new linear combinations

Principal components are linear combinations of the variables that
were originally measured, they provide a new coordinate system. The
PC in the previous example is a linear combination of *gene_x* and
*gene_y*, more specifically 

$$ PC = c__1 gene_x + c_2 gene_y $$

It has coefficients $(c_1, c_2)$, also called loading.

PCA in general will find linear combinations of the original
variables. These new linear combinations will maximise the variance
of the data.

## Summary

Principal Component Analysis (PCA) is a technique that transforms the
original n-dimensional data into a new  space.

- These new dimensions are linear combinations of the original data,
  i.e.  they are composed of proportions of the original variables.
  
- Along these new dimensions, called principal components, the data
  expresses most of its variability along the first PC, then second,
  ... 
  
- Principal components are orthogonal to each other,
  i.e. non-correlated.


```{r pcaex, echo=FALSE, fig.width=12, fig.height=4, fig.cap="Original data (left). PC1 will maximise the variability while minimising the residuals (centre). PC2 is orthogonal to PC1 (right)."}
pca <- prcomp(xy)
z <- cbind(x = c(-1, 1), y = c(0, 0))
zhat <- z %*% t(pca$rotation[, 1:2])
zhat <- scale(zhat, center = colMeans(xy), scale = FALSE)
par(mfrow = c(1, 3))
plot(xy, main = "Orignal data (2 dimensions)")
plot(xy, main = "Orignal data with PC1")
abline(lm(gene_y ~ gene_x, data = data.frame(zhat - 10)), lty = "dashed")
grid()
plot(pca$x, main = "Data in PCA space", ylim = c(-2, 2))
grid()
```

In R, we can use the `prcomp` function:

```{r irispca}
pca_xy <- prcomp(xy)
summary(pca_xy)
```

A summary of the `prcomp` output shows that along PC1 along, we are
able to retain over 92% of the total variability in the data.

```{r histpc1, echo=FALSE, fig.cap="Iris data along PC1."}
## boxplot(irispca$x[, 1] ~ iris[, 5], ylab = "PC1")
hist(irispca$x[iris$Species == "setosa", 1],
     xlim = range(irispca$x[, 1]), col = "#FF000030",
     xlab = "PC1", main = "PC1 variance explained 92%")
rug(irispca$x[iris$Species == "setosa", 1], col = "red")
hist(irispca$x[iris$Species == "versicolor", 1], add = TRUE, col = "#00FF0030")
rug(irispca$x[iris$Species == "versicolor", 1], col = "green")
hist(irispca$x[iris$Species == "virginica", 1],  add = TRUE, col = "#0000FF30")
rug(irispca$x[iris$Species == "virginica", 1], col = "blue")
```

### Visualisation

A **biplot** features all original points re-mapped (rotated) along the
first two PCs as well as the original features as vectors along the
same PCs. Feature vectors that are in the same direction in PC space
are also correlated in the original data space.

```{r irisbiplot, fig.cap=""}
biplot(irispca)
```

One important piece of information when using PCA is the proportion of
variance explained along the PCs, in particular when dealing with high
dimensional data, as PC1 and PC2 (that are generally used for
visualisation), might only account for an insufficient proportion of
variance to be relevant on their own. 

In the code chunk below, I extract the standard deviations from the
PCA result to calculate the variances, then obtain the percentage of
and cumulative variance along the PCs.
  
```{r irispcavar}
var <- irispca$sdev^2
(pve <- var/sum(var))
cumsum(pve)
```

> Challenge
> 
> - Repeat the PCA analysis on the iris dataset above, reproducing the
>   biplot and preparing a barplot of the percentage of variance
>   explained by each PC.
> - It is often useful to produce custom figures using the data
>   coordinates in PCA space, which can be accessed as `x` in the
>   `prcomp` object. Reproduce the PCA plots below, along PC1 and PC2
>   and PC3 and PC4 respectively.

```{r irispcax, echo=FALSE, fig.width=12, fig.cap=""}
par(mfrow = c(1, 2))
plot(irispca$x[, 1:2], col = iris$Species)
plot(irispca$x[, 3:4], col = iris$Species)
```

<details>
```{r irispcaxcol, eval=FALSE}
par(mfrow = c(1, 2))
plot(irispca$x[, 1:2], col = iris$Species)
plot(irispca$x[, 3:4], col = iris$Species)
```
</details>

### Data pre-processing 

We haven't looked at other `prcomp` parameters, other that the first
one, `x`. There are two other ones that are or importance, in
particular in the light of the section on pre-processing above, which
are `center` and `scale.`. The former is set to `TRUE` by default,
while the second one is set the `FALSE`.

> Challenge
> 
> Repeat the analysis comparing the need for scaling on the `mtcars`
> dataset, but using PCA instead of hierarchical clustering. When
> comparing the two.

<details>
```{r scalepcasol, fig.with=12, fig.cap=""}
par(mfrow = c(1, 2))
biplot(prcomp(mtcars, scale = FALSE), main = "No scaling")  ## 1
biplot(prcomp(mtcars, scale = TRUE), main = "With scaling") ## 2
```

Without scaling, `disp` and `hp` are the features with the highest
loadings along PC1 and 2 (all others are negligible), which are also
those with the highest units of measurement. Scaling removes this
effect.  </details>

### Final comments on PCA

Real datasets often come with **missing values**. In R, these should
be encoded using `NA`. Unfortunately, PCA cannot deal with missing
values, and observations containing `NA` values will be dropped
automatically. This is a viable solution only when the proportion of
missing values is low.

It is also possible to impute missing values. This is described in
greater details in the *Data pre-processing* section in the supervised
machine learning chapter. 

Finally, we should be careful when using categorical data in any of
the unsupervised methods described above. Categories are generally
represented as factors, which are encoded as integer levels, and might
give the impression that a distance between levels is a relevant
measure (which it is not, unless the factors are ordered). In such
situations, categorical data can be dropped, or it is possible to
encode categories as binary **dummy variables**. For example, if we
have 3 categories, say `A`, `B` and `C`, we would create two dummy
variables to encode the categories as:

```{r dummvar, echo=FALSE}
dfr <- data.frame(x = c(1, 0, 0),
                  y = c(0, 1, 0))
rownames(dfr) <- LETTERS[1:3]
knitr::kable(dfr)
```

so that the distance between each category are approximately equal to
1. 

## t-Distributed Stochastic Neighbour Embedding

[t-Distributed Stochastic Neighbour Embedding](https://lvdmaaten.github.io/tsne/) (t-SNE)
is a *non-linear* dimensionality reduction technique, i.e. that
different regions of the data space will be subjected to different
transformations. t-SNE will compress small distances, thus bringing
close neighbours together, and will ignore large distances. It is
particularly well suited
for
[very high dimensional data](https://distill.pub/2016/misread-tsne/).

In R, we can use the `Rtsne` function from the `r CRANpkg("Rtsne")`. 
Before, we however need to remove any duplicated entries in the
dataset.

```{r iristsne, fig.cap=""}
library("Rtsne")
uiris <- unique(iris[, 1:5])
iristsne <- Rtsne(uiris[, 1:4])
plot(iristsne$Y, col = uiris$Species)
```

As with PCA, the data can be scaled and centred prior the running
t-SNE (see the `pca_center` and `pca_scale` arguments). The algorithm
is stochastic, and will produce different results at each repetition.

### Parameter tuning

t-SNE (as well as many other methods, in particular classification
algorithms) has two important parameters that can substantially
influence the clustering of the data

- **Perplexity**: balances global and local aspects of the data.
- **Iterations**: number of iterations before the clustering is
  stopped.

It is important to adapt these for different data. The figure below
shows a 5032 by 20 dataset that represent protein sub-cellular
localisation.

![Effect of different perplexity and iterations when running t-SNE](https://raw.githubusercontent.com/lgatto/visualisation/master/figure/tsnesplots-1.png)

As a comparison, below are the same data with PCA (left) and t-SNE
(right).

![PCA and t-SNE on hyperLOPIT](https://raw.githubusercontent.com/lgatto/visualisation/master/figure/tsneex-1.png)
